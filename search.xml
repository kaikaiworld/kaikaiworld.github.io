<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dive Into Python 3 翻译 目录</title>
    <url>/posts/dive-into-python-3-fan-yi-mu-lu/</url>
    <content><![CDATA[<p>这段时间在自学 Python 3，在网上找了 Dive Into Python 3 的中文版来看，读起来都觉得怪怪的，索性找来英文原版。边看边自己翻译，发在这留个记录吧。</p>
<a id="more"></a>

<p><a href="https://hexo.kaikai.world/posts/dive-into-python-3-fan-yi-fu-yi-zhang/">#-1《深入 Python 3 中有什么新内容》</a></p>
<p><a href="https://hexo.kaikai.world/posts/dive-into-python-3-fan-yi-di-ling-zhang/">#0  《Python 的安装》</a></p>
<p><a href="https://hexo.kaikai.world/posts/dive-into-python-3-fan-yi-di-yi-zhang/">#1  《你的第一个 Python 程序》</a></p>
<p>TBD</p>
]]></content>
      <tags>
        <tag>Python 之路</tag>
      </tags>
  </entry>
  <entry>
    <title>Dive Into Python 3 翻译 负一章</title>
    <url>/posts/dive-into-python-3-fan-yi-fu-yi-zhang/</url>
    <content><![CDATA[<h2 id="负一章-深入-Python-3-中有什么新内容"><a href="#负一章-深入-Python-3-中有什么新内容" class="headerlink" title="负一章 - 深入 Python 3 中有什么新内容"></a>负一章 - 深入 Python 3 中有什么新内容</h2><hr>
<p><em>“这不正是我们进来的地方吗？”</em></p>
<p><em>- Pink · Floyd, The Wall</em></p>
<a id="more"></a>


<h4 id="1-1-又被称为-“THE-MINUS-LEVEL”"><a href="#1-1-又被称为-“THE-MINUS-LEVEL”" class="headerlink" title="-1.1 又被称为 “THE MINUS LEVEL”"></a>-1.1 又被称为 “THE MINUS LEVEL”</h4><p>你已经是一个 Python 程序员了吗？你读过原版的 《<a href="http://diveintopython.org/">深入 Python</a>》了吗？你买纸质书了吗？（如果买了，谢谢你！）你准备好冒险进入 Python 3 了吗？如果都做到了，请接着读。（如果没有，你最好从头开始）</p>
<p>伴随着 Python 3 一起来的还有一个被叫做 2to3 的脚本。学习它，爱上它，使用它。《用 2to3 移植代码到 Python 3》是一个 2to3 工具可以自动修复的所有事情的参考书。由于许多改变都是语法上的，所以先了解这些在 Python 3 中的语法变化真的是一个好的开始。</p>
<p>案例学习：” 把 Chardet 移植到 Python 3 “ 记录了在我的努力下（最终成功了）把一个不平常的库从 Python 2 移植到 Python 3。它可能对你有帮助，也可能没有。由于你需要先理解这个库，才能理解它为什么中断了和我怎么修复了它，因此这个学习曲线是相当陡峭。许多损坏都围绕着 Strings，说起这个…</p>
<p>Strings，吁，从哪说起呢，Python 2 有 “Strings” 和 “Unicode (统一码) Strings”。Python 3 中有 “Bytes” 和 “Strings”。这就是说，现在所有的 Strings 都是 Unicode Strings ，而且如果你想要处理一堆 bytes，你可以使用新的 bytes 类型，Python 3 永远不会在 Strings 和 bytes 之间进行隐式转换，所以如果你不确定在哪些时候使用哪种类型，你的代码肯定会中断。想要了解更多的细节可以阅读 the Strings Chapter。</p>
<p>在这本书中，Bytes 和 Strings 的比较将会反复出现。</p>
<ul>
<li><p>  在《文件》(Files) 中，你会学习” 二进制” 和” 文本” 这两种读取文件的模式之间的不同之处，以文本模式读取（写入也是！）文件要求一个 encoding 参数，一些文本文件的方法按照字符计数，但是其他的方法却按照字节计数。如果你的代码中假定一个字符等于一个字节，当遇到多字节字符的时候就会中断。</p>
</li>
<li><p>  在《HTTP 网页服务》(HTTP Web Services) 中，httplib 2 模块通过 HTTP 接受 headers 和 data。HTTP headers 以 strings 类型返回，而 HTTP body 以 bytes 类型返回。</p>
</li>
<li><p>  在《可序列化 Python 类》(Serializing Python Objects) 中，你将会学习到为什么 pickle 模块这个在 Python 3 中定义的新的数据格式会不与 Python 2 向后兼容（提示：因为 bytes 和 strings）。此外，Python 3 还支持可序列化类与 JSON 之间相互转换，尽管 JSON 都不是 bytes 类型。我将会给你展示这是怎么做到的。</p>
</li>
<li><p>在案例学习：把 chardet 移植到 Python 3 中，到处都是 bytes 和 strings。</p>
<p>即使你不关心 Unicode（但是你会关心的），你也会想读读 Python 3 中的字符串格式 (string formatting in Python 3)，它和 Python 2 中的完全不同。</p>
<p>在 Python 3 中到处都是迭代器 (Iterators)，我现在比五年前写《深入 Python》的时候能更好的理解它们了，你也要理解它们，因为很多之前在 Python 2 中返回列表 (lists) 的函数，现在变成返回迭代器了。你最少也得读一读迭代器这章的后半部分和高级迭代器这章的后半部分。</p>
</li>
</ul>
<p>应广大程序猿的要求，我已经在附录上增加了《特殊方法名称》这一部分，这有点像 <a href="http://www.python.org/doc/3.1/reference/datamodel.html#special-method-names">Python 文档的《数据模型 (data model) 》</a>这章，但是更加鬼魅。</p>
<p> 当我写《深入 Python》的时候，所有能获取到的 XML 库都有问题。后来 Fredrik Lundh 编写了 <a href="http://effbot.org/zone/element-index.htm">ElementTree</a> ，这些就都变好了。Python 领域的偶像们很明智地 <a href="http://docs.python.org/3.1/library/xml.etree.elementtree.html">把 ElementTree 纳入到标准库中</a> ，现在也形成了我新写的 XML 那章的基础。老的对 XML 进行解析的方法仍然能用，但是你最好别用，因为它们真的都很糟糕。</p>
<p> 在 Python 中另外的新东西，不在语言而在社区，出现了像 <a href="http://pypi.python.org/">Python 软件包大全 (The Python Package Index, PyPI)</a> 这样的代码仓库， Python 带来了把你的代码用标准格式打包然后发行到 PyPI 上的实用工具。想要了解细节请阅读打包 Python 库 (Packaging Python Libraries) 这一章。</p>
]]></content>
      <tags>
        <tag>Python 之路</tag>
      </tags>
  </entry>
  <entry>
    <title>Dive Into Python 3 翻译 第零章</title>
    <url>/posts/dive-into-python-3-fan-yi-di-ling-zhang/</url>
    <content><![CDATA[<h3 id="第零章-Python-的安装"><a href="#第零章-Python-的安装" class="headerlink" title="第零章 - Python 的安装"></a>第零章 - Python 的安装</h3><hr>
<p><em>“时间在变化，我们也随之变化。”</em></p>
<p><em>- 古罗马谚语</em></p>
<a id="more"></a>

<h4 id="0-1-深入"><a href="#0-1-深入" class="headerlink" title="0.1. 深入"></a>0.1. 深入</h4><p>在你开始用 Python 3 编程之前，你需要先安装它。或许你已经装好了。</p>
<h4 id="0-2-哪个版本的-Python-最适合你？"><a href="#0-2-哪个版本的-Python-最适合你？" class="headerlink" title="0.2. 哪个版本的 Python 最适合你？"></a>0.2. 哪个版本的 Python 最适合你？</h4><p>如果你用的是一个托管服务器上的账号，那你的 ISP 可能已经装好了 Python 3 。如果你在家里运行了一个 Linux，那你也可能已经装好了 Python 3 。大部分流行的 GUN/Linux 发行版默认安装了 Python 2，包含 Python 3 的数量虽然很少，但是一直在增加。 Mac OS X 包含了一个命令行版本的 Python 2，但是直到本书写作的时候还没有包含 Python 3 。Microsoft Windows 没有自带任何版本的 Python 。但是别绝望！不用理会你用的什么操作系统，你都能点出条安装 Python 的道儿来。</p>
<p>检查你的 Linux 或者 Mac OS X 上是否有 Python 3 的最简单的方法就是用命令行。一旦你看到命令行提示符，就输入 <code>python3</code> （全部小写，没有空格），按回车，然后看看发生了什么。在我家的 Linux 系统上，Python 3.1 已经被装好了，这行命令还让我进入了 Python 交互式 shell 中。</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">mark@atlantis:~$ python3</span><br><span class="line">Python 3.1 (r31:73572, Jul 28 2009, 06:52:23)</span><br><span class="line">[GCC 4.2.4 (Ubuntu 4.2.4-1ubuntu4)] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>（输入 <code>exit()</code> 然后按回车就可以退出交互式 Python Shell。）</p>
<p>我的网页主机供应商也运行着 Linux 还允许命令行访问，但是我的服务器上并没有安装 Python 3（爆炸！）。</p>
<figure class="highlight elixir"><table><tbody><tr><td class="code"><pre><span class="line">mark<span class="variable">@manganese</span><span class="symbol">:~</span><span class="variable">$ </span>python3</span><br><span class="line"><span class="symbol">bash:</span> <span class="symbol">python3:</span> command <span class="keyword">not</span> found</span><br></pre></td></tr></tbody></table></figure>

<p>无论你的电脑上已经运行了哪个版本的 Python，都请回到这部分开始时的问题，” 哪个版本的 Python 最适合你？”</p>
<p>[接下来是 Windows 版本的介绍，你可以跳到在 Mac OS X 上的安装，在 Ubuntu Linux 上的安装，或者是在其他平台上的安装。]</p>
<h4 id="0-3-在Microsoft-Windows-上安装"><a href="#0-3-在Microsoft-Windows-上安装" class="headerlink" title="0.3. 在Microsoft Windows 上安装"></a>0.3. 在 Microsoft Windows 上安装</h4><p>当前 Windows 有两种体系结构：32 位和 64 位。当然，在不同的 Windows 版本之间还有很多不同 - XP，Vista，Windows 7 - 但是 Python 可以在它们所有上面运行。最重要的差别就是 32 位和 64 位之间。如果你不知道你运行着哪个体系结构，可能就是 32 位。</p>
<p>访问 <a href="http://python.org/download/">Python.org/download/</a> 然后下载适合你的体系结构的 Python 3 Windows 安装器。你的选择可能看起来像下面这些：</p>
<ul>
<li>  Python 3.1 Windows installer (Windows binary-does not include source)</li>
<li>  Python 3.1 Windows AMD64 installer (Windows AMD64 binary-does not include source)</li>
</ul>
<p>我不想在这直接包含直接下载链接，因为 Python 一直在进行微小的更新，而且我不想因为我的责任让你错过重要的更新。你应该总是安装最新版本的 Python 3.x，除非你有什么更深层次的原因让你不能这么干。</p>
<p>当你下载完成之后，双击那个 .msi 文件。由于你突然运行了一个可执行代码，Windows 将弹出一个安全警报。这个官方的 Python 安装器已经被负责 Python 开发的非盈利组织 <a href="http://www.python.org/psf/">Python 软件基金会</a> 进行过数字签名了。不要使用盗版软件。</p>
<p>点击 run 按钮启动 Python 3 安装器。</p>
<p>。。。后边的安装过程不想翻了，偷个懒。</p>
<p>好了现在我们已经装好了 Python 3。</p>
<h4 id="0-7-使用-Python-Shell"><a href="#0-7-使用-Python-Shell" class="headerlink" title="0.7. 使用 Python Shell"></a>0.7. 使用 Python Shell</h4><p>你可以在 Python Shell 中探索 Python 语法的用法，用命令获取交互式的帮助，调试短的程序。这个图形化的 Python Shell（被称为 IDLE）也包括了一个还不错的文本编辑器，它支持 Python 的语法高亮，还和 Python Shell 整合在一起。如果你已经有个喜欢的文本编辑器，你也应该给 IDLE 一个机会。</p>
<p>开始的开始（译者注：我们都是孩子）。Python Shell 就是一个了不起的交互环境。通过这本书，你将会了解到像这样的例子：</p>
<figure class="highlight angelscript"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>
<p>这三个角括号，<code>&gt;&gt;&gt;</code>，表示 Python Shell 提示符，不用输入那部分。这仅仅是让你知道这个例子是运行在 Python Shell 中的。</p>
<p>1 + 1 是你输入的部分。你能在 Python Shell 中输入任何有效的 Python 表达式或者命令。不要害羞嘛，它不会咬你的。将要发生的最糟糕的情况不过就是你会得到一个错误信息。命令会立即被执行（一旦你按下回车），表达式立即被计算，然后 Python Shell 就输出结果了。</p>
<p>2 是这个表达式计算出来的结果。很巧，1 + 1 是一个有效的 Python 表达式，当然，结果是 2。</p>
<p>让我们再试一个。</p>
<figure class="highlight python-repl"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt;</span> <span class="python">print(<span class="string">'Hello world!'</span>)</span></span><br><span class="line">Hello world!</span><br></pre></td></tr></tbody></table></figure>

<p>相当简单，对吧？但是你能在 Python Shell 中做到的还有更多。如果你卡壳了 - 你忘了一条命令，或者你不记得要给某个函数传递哪个参数合适 - 那你能在 Python Shell 里获得交互式的帮助。就输入 <code>help</code> 然后回车就可以了。</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; help</span><br><span class="line">Type help() <span class="keyword">for</span> interactive help, <span class="keyword">or</span> help(object) <span class="keyword">for</span> help about object.</span><br></pre></td></tr></tbody></table></figure>
<p>有两种获取帮助的模式。你可以获取关于一个类的帮助，这样可以输出这个类的文档然后返回到 Python Shell 提示符。你还可以进入 help 模式而不是计算 Python 表达式，你只需要输入关键词或者命令的名字，它就会输出所有有关这个命令的东西。</p>
<p>要进入交互式帮助模式，请输入 <code>help()</code> 然后按回车。</p>
<figure class="highlight livecodeserver"><table><tbody><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; help()</span><br><span class="line">Welcome <span class="built_in">to</span> Python <span class="number">3.0</span>! This is <span class="keyword">the</span> online help utility.</span><br><span class="line">If this is your <span class="keyword">first</span> <span class="built_in">time</span> <span class="keyword">using</span> Python, you should definitely check out</span><br><span class="line"><span class="keyword">the</span> tutorial <span class="keyword">on</span> <span class="title">the</span> <span class="title">Internet</span> <span class="title">at</span> <span class="title">http</span>://<span class="title">docs</span>.<span class="title">python</span>.<span class="title">org</span>/<span class="title">tutorial</span>/.</span><br><span class="line">Enter <span class="keyword">the</span> name <span class="keyword">of</span> <span class="keyword">any</span> module, keyword, <span class="keyword">or</span> topic <span class="built_in">to</span> <span class="built_in">get</span> help <span class="keyword">on</span> <span class="title">writing</span></span><br><span class="line">Python programs <span class="keyword">and</span> <span class="keyword">using</span> Python modules. To quit this help utility <span class="keyword">and</span></span><br><span class="line"><span class="literal">return</span> <span class="built_in">to</span> <span class="keyword">the</span> interpreter, just type <span class="string">"quit"</span>.</span><br><span class="line">To <span class="built_in">get</span> <span class="keyword">a</span> list <span class="keyword">of</span> available modules, keywords, <span class="keyword">or</span> topics, type <span class="string">"modules"</span>,</span><br><span class="line"><span class="string">"keywords"</span>, <span class="keyword">or</span> <span class="string">"topics"</span>. Each module also comes <span class="keyword">with</span> <span class="keyword">a</span> <span class="literal">one</span>-<span class="built_in">line</span> summary</span><br><span class="line"><span class="keyword">of</span> what <span class="keyword">it</span> does; <span class="built_in">to</span> list <span class="keyword">the</span> modules whose summaries contain <span class="keyword">a</span> given <span class="built_in">word</span></span><br><span class="line">such <span class="keyword">as</span> <span class="string">"spam"</span>, type <span class="string">"modules spam"</span>.</span><br><span class="line">help&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>注意提示符从 <code>&gt;&gt;&gt;</code> 变成了 <code>help&gt;</code>。这提醒你现在正处在交互式帮助模式。现在你可以输入任何关键词，命令，模块名，函数名 - 几乎一切 Python 可以理解的东西 - 然后就可以阅读关于它的文档。</p>
<figure class="highlight routeros"><table><tbody><tr><td class="code"><pre><span class="line">help&gt; <span class="builtin-name">print</span>                                                               ①</span><br><span class="line">Help on built-in function <span class="builtin-name">print</span> <span class="keyword">in</span> module builtins:</span><br><span class="line"><span class="builtin-name">print</span>(<span class="built_in">..</span>.)</span><br><span class="line"><span class="builtin-name">print</span>(value, <span class="built_in">..</span>., <span class="attribute">sep</span>=<span class="string">' '</span>, <span class="attribute">end</span>=<span class="string">'\n'</span>, <span class="attribute">file</span>=sys.stdout)</span><br><span class="line">Prints the values <span class="keyword">to</span> a stream, <span class="keyword">or</span> <span class="keyword">to</span> sys.stdout by default.</span><br><span class="line">Optional keyword arguments:</span><br><span class="line">file: a file-like object (stream); defaults <span class="keyword">to</span> the current sys.stdout.</span><br><span class="line">sep: string inserted between values,<span class="built_in"> default </span>a space.</span><br><span class="line">end: string appended after the last value,<span class="built_in"> default </span>a newline.</span><br><span class="line">help&gt; PapayaWhip                                                          ②</span><br><span class="line"><span class="literal">no</span> Python documentation found <span class="keyword">for</span> <span class="string">'PapayaWhip'</span></span><br><span class="line">help&gt; quit                                                                ③</span><br><span class="line">You are now leaving help <span class="keyword">and</span> returning <span class="keyword">to</span> the Python interpreter.</span><br><span class="line"><span class="keyword">If</span> you want <span class="keyword">to</span> ask <span class="keyword">for</span> help on a particular object directly <span class="keyword">from</span> the</span><br><span class="line">interpreter, you can<span class="built_in"> type </span><span class="string">"help(object)"</span>. Executing <span class="string">"help('string')"</span></span><br><span class="line">has the same effect as typing a particular string at the help&gt; prompt.</span><br><span class="line">&gt;&gt;&gt;                                                                       ④</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li> 想要获取函数 <code>print()</code> 的文档，输入 <code>print</code> 然后回车就行了。这个交互式帮助模式将显示一个类似于操作手册的东西：函数名，一个简介，函数的参数和它们的默认值等等。如果这些文档对你来说有点难懂，不慌，问题不大。你会在接下来的几章里会更加了解这些概念。</li>
<li> 当然，这个交互式帮助文档不是所有的事情都知道。如果你输入的东西不是 Python 命令，模块，函数或者其他内置的关键词，这个交互式帮助模式只能耸耸它那不存在的肩膀罢了。</li>
<li> 输入 <code>quit</code> 然后按回车就可以退出交互式帮助模式。</li>
<li> 提示符变回 <code>&gt;&gt;&gt;</code> 表明你已经离开了交互式帮助模式，回到了 Python Shell。</li>
</ol>
<p>IDLE，这个图形化的 Python Shell 也包含了一个 Python 相关的文本编辑器。</p>
<h4 id="0-8-Python-编辑器和集成开发环境"><a href="#0-8-Python-编辑器和集成开发环境" class="headerlink" title="0.8. Python 编辑器和集成开发环境"></a>0.8. Python 编辑器和集成开发环境</h4><p>当谈到用 Python 编程时，IDLE 并不是唯一的选择。虽然它对刚开始学这门语言的人很有用，但是许多开发者更喜欢其它的文本编辑器或者集成开发环境 (IDEs)。我就不在此赘述了，Python 社区维护了 <a href="http://wiki.python.org/moin/PythonEditors">一个 Python 相关的编辑器的清单</a> ，包含了各种各样的支持平台和软件许可证。</p>
<p>你可能还想要看看 <a href="http://wiki.python.org/moin/IntegratedDevelopmentEnvironments">Python 相关的集成开发环境的清单</a> ，虽然他们中支持 Python 3 的不多。其中一个就是 <a href="http://pydev.sourceforge.net/">PyDev</a> ，一个能使 Eclipse 变成全功能 Python 集成开发环境的 <a href="http://eclipse.org/">Eclipse</a> 插件。Eclipse 和 PyDev 都是跨平台而且开源的。</p>
<p>在商业方面，可以用 ActiveState 公司的 <a href="http://www.activestate.com/komodo/">Komodo IDE</a> 。使用它需要购买单用户授权，但是学生党可以打个折，还能下载免费的限时试用版本。</p>
<p>我用 Python 编程已经九年了，我用 <a href="http://www.gnu.org/software/emacs/">GNU Emacs</a> 编辑我的 Python 程序然后在 Python Shell 命令行中调试它们。没有什么开发 Python 的方式是正确或者错误的。你要找到一个适合你的方式。</p>
]]></content>
      <tags>
        <tag>Python 之路</tag>
      </tags>
  </entry>
  <entry>
    <title>Dive Into Python 3 翻译 第一章</title>
    <url>/posts/dive-into-python-3-fan-yi-di-yi-zhang/</url>
    <content><![CDATA[<h3 id="第一章-你的第一个-Python-程序"><a href="#第一章-你的第一个-Python-程序" class="headerlink" title="第一章 - 你的第一个 Python 程序"></a>第一章 - 你的第一个 Python 程序</h3><hr>
<p><em>“不要把你的负担埋葬在圣寂中。你有难题吗？很好。欢呼吧，然后深入进去，开始调查。”</em></p>
<p><em>- Ven. Henepola Gunaratana</em></p>
<a id="more"></a>

<h4 id="1-1-深入"><a href="#1-1-深入" class="headerlink" title="1.1. 深入"></a>1.1. 深入</h4><p>按照惯例我应该从一些基础的编程语句块开始讲，然后我们逐步构建一些有用的东西，但是这会让你觉得很无聊。咱们就把那些都跳过，这有个完整的能用的 Python 程序。你可能完全看不懂。不慌，我会带你一行行的分析。但是首先你得通读一遍，理解你能看懂的任何东西。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">SUFFIXES = {<span class="number">1000</span>: [<span class="string">'KB'</span>, <span class="string">'MB'</span>, <span class="string">'GB'</span>, <span class="string">'TB'</span>, <span class="string">'PB'</span>, <span class="string">'EB'</span>, <span class="string">'ZB'</span>, <span class="string">'YB'</span>],</span><br><span class="line">            <span class="number">1024</span>: [<span class="string">'KiB'</span>, <span class="string">'MiB'</span>, <span class="string">'GiB'</span>, <span class="string">'TiB'</span>, <span class="string">'PiB'</span>, <span class="string">'EiB'</span>, <span class="string">'ZiB'</span>, <span class="string">'YiB'</span>]}</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">approximate_size</span>(<span class="params">size, a_kilobyte_is_1024_bytes=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="string">'''Convert a file size to human-readable form.</span></span><br><span class="line"><span class="string">    Keyword arguments:</span></span><br><span class="line"><span class="string">    size -- file size in bytes</span></span><br><span class="line"><span class="string">    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024</span></span><br><span class="line"><span class="string">                                if False, use multiples of 1000</span></span><br><span class="line"><span class="string">    Returns: string</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="keyword">if</span> size &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'number must be non-negative'</span>)</span><br><span class="line"></span><br><span class="line">    multiple = <span class="number">1024</span> <span class="keyword">if</span> a_kilobyte_is_1024_bytes <span class="keyword">else</span> <span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> suffix <span class="keyword">in</span> SUFFIXES[multiple]:</span><br><span class="line">        size /= multiple</span><br><span class="line">        <span class="keyword">if</span> size &lt; multiple:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'{0:.1f} {1}'</span>.<span class="built_in">format</span>(size, suffix)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'number too large'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(approximate_size(<span class="number">1000000000000</span>, <span class="literal">False</span>))</span><br><span class="line">    print(approximate_size(<span class="number">1000000000000</span>))</span><br></pre></td></tr></tbody></table></figure>

<p>现在让我们在命令行中运行一下这个程序。在 Windows 平台上，它的结果看起来类似这样：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">c:\home\diveintopython3\examples&gt; c:\python31\python.exe humansize.py</span><br><span class="line"><span class="number">1.0</span> TB</span><br><span class="line"><span class="number">931.3</span> GiB</span><br></pre></td></tr></tbody></table></figure>

<p>在 Mac OS X 或者 Linux 平台上，结果看起来类似这样：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">you@localhost:~/diveintopython3/examples$ python3 humansize.py</span><br><span class="line"><span class="number">1.0</span> TB</span><br><span class="line"><span class="number">931.3</span> GiB</span><br></pre></td></tr></tbody></table></figure>

<p>刚刚发生了啥？你执行了你的第一个 Python 程序。你在命令行里调用了 Python 解释器，然后你传递了你想让 Python 去执行的脚本名。这个脚本定义了一个函数，这个 <code>approximate_size()</code> 函数，他将会计算出一个确切的以 <code>byte</code> 为单位的文件大小，然后计算成易读的（但是是近似值）的大小。（你可能已经在 Windows 资源管理器，或者 Mac OS X 访达，或者 Linux 的 Nautilus，Dolphin，Thunar 上看到过了。如果你以多列列表的形式显示一个包含文档的文件夹，它将会显示一个包括文档图标，文档名，大小，类型，最后修改时间等等的表。如果文件夹包含一个 1093 字节的叫 TODO 的文件，你的文件管理器不会显示 <code>TODO 1093 bytes</code>，而是类似 <code>TODO 1KB</code>。这就是 <code>approximate_size()</code> 所做的事。）</p>
<p>看脚本的结尾，你会看到两次调用 <code>print(approximate_size(arguments))</code>。这些函数调用是这样子的：第一次调用 <code>approximate_size()</code> 函数，同时传递了一些参数，然后把返回值直接传递给了 <code>print()</code> 函数。<code>print()</code> 函数是内置的，你不会看到对它的显式声明。无论何时无论何地你都可以使用它。（还有很多内置的函数，更多的函数被分在了不同的模块（module）里。耐心点，慢慢来。）</p>
<p>所以为什么在命令行里运行的脚本每次都给你一样的输出结果呢？我们就快说到这了。首先，让我们先看一眼 <code>approximate_size()</code> 这个函数。</p>
<h4 id="1-2-声明函数"><a href="#1-2-声明函数" class="headerlink" title="1.2. 声明函数"></a>1.2. 声明函数</h4><p>Python 的函数和其他大多数语言都差不多，但是他不像 C++ 那样被隔离在头文件里或者 Pascal 的 interface/implementation 部分。当你需要一个函数时声明它就行了，就像这样：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">approximate_size</span>(<span class="params">size, a_kilobyte_is_1024_bytes=<span class="literal">True</span></span>):</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个关键词 <code>def</code> 标志着函数声明的开始，紧跟着是函数名，然后是在圆括号中的参数表。多个参数用逗号隔开。</p>
<p>还要注意这个函数没有定义一个返回类型。Python 函数不用为它们的返回值特定一个类型；它们甚至不用具体说明是否有返回值。（事实上，每个 Python 函数都会返回一个值，如果函数在任何时候执行了一个 <code>return</code> 语句，它将会返回那个值，否则它将会返回 None，即 Python 中的 null。）</p>
<blockquote>
<p>在一些语言中，函数（带返回值的）以 <code>function</code> 开头，而子程序 (subroutines，没有返回值) 以 <code>sub</code> 开头。在 Python 中没有子程序这个概念。所有东西都是一个函数，所有的函数都有返回值（即使返回 None），而且所有函数都以 <code>def</code> 开头。</p>
</blockquote>
<p>这个 <code>approximate_size()</code> 函数有两个参数： <code>size</code> 和 <code>a_kilobyte_is_1024_bytes</code>，但是没有一个参数具体说明了它的数据类型。在 Python 中，变量永远不被显式地指定类型。Python 会弄清楚某个变量是什么类型并且在内部跟踪它。</p>
<blockquote>
<p>在 Java 和其他静态类型语言中，你必须具体说明函数返回值和每个参数的数据类型。而在 Python 中，你永远不用显式定义任何东西的数据类型。Python 会给予你的赋值而在内部跟踪数据类型。</p>
</blockquote>
<h5 id="1-2-1-可选参数和具名参数"><a href="#1-2-1-可选参数和具名参数" class="headerlink" title="1.2.1. 可选参数和具名参数"></a>1.2.1. 可选参数和具名参数</h5><p>Python 允许带有默认值的函数参数，如果函数被调用的时候没有传递参数，那么这个参数会使用它的默认值。而且通过使用具名参数可以用任何顺序指定参数。</p>
<p>让我们再看一眼函数 <code>approximate_size()</code> 的声明：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">approximate_size</span>(<span class="params">size, a_kilobyte_is_1024_bytes=<span class="literal">True</span></span>):</span></span><br></pre></td></tr></tbody></table></figure>

<p>第二个参数 <code>a_kilobyte_is_1024_bytes</code>，指定了 True 为默认值。这意味着这个参数是可选的。你可以在调用函数的时候不指定这个参数，Python 将会视为你把 True 作为第二个参数调用了这个函数。</p>
<p>现在看一眼脚本的结尾：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(approximate_size(<span class="number">1000000000000</span>, <span class="literal">False</span>))                       ①</span><br><span class="line">    print(approximate_size(<span class="number">1000000000000</span>))                              ②</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li> 这一句在调用 <code>approximate_size()</code> 时传递了两个参数。由于你明确地把 <code>False</code> 作为第二个参数传递了，所以在 <code>approximate_size()</code> 函数中，<code>a_kilobyte_is_1024_bytes</code> 会是 <code>False</code>。</li>
<li> 这一句在调用 <code>approximate_size()</code> 时只传递了一个参数。不过这也是可以的，因为第二个参数是可选的！由于调用者没有具体说明，所以第二个参数为函数声明中的默认值，即 <code>True</code>。</li>
</ol>
<p>你也可以通过参数名传递参数。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> humansize <span class="keyword">import</span> approximate_size</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>approximate_size(<span class="number">4000</span>, a_kilobyte_is_1024_bytes=<span class="literal">False</span>)               ①</span><br><span class="line"><span class="string">'4.0 KB'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>approximate_size(size=<span class="number">4000</span>, a_kilobyte_is_1024_bytes=<span class="literal">False</span>)          ②</span><br><span class="line"><span class="string">'4.0 KB'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>approximate_size(a_kilobyte_is_1024_bytes=<span class="literal">False</span>, size=<span class="number">4000</span>)          ③</span><br><span class="line"><span class="string">'4.0 KB'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>approximate_size(a_kilobyte_is_1024_bytes=<span class="literal">False</span>, <span class="number">4000</span>)               ④</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">SyntaxError: non-keyword arg after keyword arg</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>approximate_size(size=<span class="number">4000</span>, <span class="literal">False</span>)                                   ⑤</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">SyntaxError: non-keyword arg after keyword arg</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li> 这次调用 <code>approximate_size()</code> 时给第一个参数 <code>size</code> 传了 <code>4000</code>，给具名参数 <code>a_kilobyte_is_1024_bytes</code> 传了 <code>False</code>。（那碰巧是第二个参数，但是也没关系，你马上就会懂了。）</li>
<li> 这次调用 <code>approximate_size()</code> 时给具名参数 <code>size</code> 传了 <code>4000</code>，给具名参数 <code>a_kilobyte_is_1024_bytes</code> 传了 <code>False</code>。（这些具名参数刚好和函数声明中的参数列表是一样的顺序，但是那同样不要紧。）</li>
<li> 这次调用 <code>approximate_size()</code> 时给 <code>a_kilobytes_is_1024_bytes</code> 传了 <code>False</code>，给 <code>size</code> 传了 <code>4000</code>。（看到了吗？我告诉过你了顺序不重要）</li>
<li> 这次调用失败了，因为你在一个具名参数后面跟了个未命名（按位）参数，所以那不会有效。从左到右读这个参数列表，一旦你用了一次具名参数，剩下的参数都必须要带名字。</li>
<li> 这个也失败了，和前一次是一样的原因。惊讶吗？毕竟，你给 <code>size</code> 传了 <code>4000</code>，很明显那个 <code>False</code> 就是传给 <code>a_kilobyte_is_1024_bytes</code> 的。但是 Python 不认识这种写法。你用一个具名参数，右边的参数就都得是具名参数。</li>
</ol>
<h4 id="1-3-编写易读的代码"><a href="#1-3-编写易读的代码" class="headerlink" title="1.3. 编写易读的代码"></a>1.3. 编写易读的代码</h4><p>我不会给你来一段长的让人直摇手指的演讲来告诉你给你的代码写文档的重要性，这太无聊了。你只需要知道代码虽然只写一次但是在写完之后的六个月内会经常被读，而且你的代码最重要的作者就是你自己（比如你需要修补某些地方，但是你全忘完了）。Python 把编写易读的代码变得很容易，所以就好好利用它的优势咯。不到六个月你肯定会来感谢我的。</p>
<h5 id="1-3-1-文档字符串"><a href="#1-3-1-文档字符串" class="headerlink" title="1.3.1. 文档字符串"></a>1.3.1. 文档字符串</h5><p>你可以用文档字符串（<code>documentation string</code>  缩写是 <code>docstring</code>）来给一个 Python 函数写文档。在这个程序中，函数 <code>approximate_size()</code> 有一个文档字符串。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">approximate_size</span>(<span class="params">size, a_kilobyte_is_1024_bytes=<span class="literal">True</span></span>):</span></span><br><span class="line">    <span class="string">'''Convert a file size to human-readable form.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Keyword arguments:</span></span><br><span class="line"><span class="string">    size -- file size in bytes</span></span><br><span class="line"><span class="string">    a_kilobyte_is_1024_bytes -- if True (default), use multiples of 1024</span></span><br><span class="line"><span class="string">                                if False, use multiples of 1000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns: string</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    '''</span></span><br></pre></td></tr></tbody></table></figure>

<p>三引号表示一个多行字符串。在开始和结尾的引号中间的所有东西都是这一个字符串的一部分，包括回车换行符，前导空格和其它的引号字符。你可以在任何地方使用他们，但是你最常见的用法是定义一个文档字符串。</p>
<blockquote>
<p>三引号也是一个定义包含单引号和双引号字符串的捷径，就像 Perl 5 中的 qq/…/。</p>
</blockquote>
<p>在三引号之间的所有东西都是这个函数的记录函数的功能的文档字符串。如果存在文档字符串，那它必须是函数里定义的第一个东西（就在在函数声明的下一行）。你不用严格地给你的函数写文档字符串，但是你必须得写。你可能你上过的其他语言的编程班上也听过这个，但是 Python 还给你了一个额外的好处：文档字符串像函数的属性一样在运行时也可以获取到。</p>
<blockquote>
<p>许多 Python IDE 都用 文档字符串来提供上下文关联的文档，这样一来当你输入一个函数名的时候，它的文档字符串就会像工具提示那样出现了。这个功能极其有用，但是它取决于你的文档字符串写得有多好。</p>
</blockquote>
<h4 id="1-4-import-的搜索路径"><a href="#1-4-import-的搜索路径" class="headerlink" title="1.4. import 的搜索路径"></a>1.4. import 的搜索路径</h4><p>在进行下一步讲解之前，我想简单提一下库的搜索路径。当你试图导入一个模块时，Python 会在好几个地方查找。具体来说，它会在 <code>sys.path</code> 中定义的目录查找。它就是个列表，你很容易用标准的列表方法查看或者修改它（你会在 Native Datatypes 中了解到更多关于列表的信息）。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys                                                             ①</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path                                                               ②</span><br><span class="line">[<span class="string">''</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python31.zip'</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python3.1'</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python3.1/plat-linux2@EXTRAMACHDEPPATH@'</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python3.1/lib-dynload'</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python3.1/dist-packages'</span>,</span><br><span class="line"> <span class="string">'/usr/local/lib/python3.1/dist-packages'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys                                                                    ③</span><br><span class="line">&lt;module <span class="string">'sys'</span> (built-<span class="keyword">in</span>)&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path.insert(<span class="number">0</span>, <span class="string">'/home/mark/diveintopython3/examples'</span>)              ④</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path                                                               ⑤</span><br><span class="line">[<span class="string">'/home/mark/diveintopython3/examples'</span>,</span><br><span class="line"> <span class="string">''</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python31.zip'</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python3.1'</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python3.1/plat-linux2@EXTRAMACHDEPPATH@'</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python3.1/lib-dynload'</span>,</span><br><span class="line"> <span class="string">'/usr/lib/python3.1/dist-packages'</span>,</span><br><span class="line"> <span class="string">'/usr/local/lib/python3.1/dist-packages'</span>]</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li> 导入 <code>sys</code> 模块能让它的全部函数和属性变成可获取状态。</li>
<li> <code>path</code> 是一个构成当前搜索路径的目录名的列表。（根据你的操作系统，正在运行的 Python 版本和它的初始安装位置，你会看到不同的内容。）Python 会遍历这些目录以找到和你试图导入的名字匹配的 .py 文件。</li>
<li> 实际上，我撒谎了。真相比刚才更复杂，因为不是所有的模块都以 .py 文件存储。一些内置模块实际上被整合到 Python 里边了。内置模块和常规模块用起来一样，但是不能获取到它们的 Python 源代码，因为它们都不是用 Python 写的！（像 Python 本身一样，这些内置函数都是用 C 写的。）</li>
<li> 你可以在运行时通过在 <code>path</code> 中增加一个目录的方式在 Python 的搜索路径中增加一个新的目录，然后不管什么时候你试图导入一个模块， Python 也会在那个目录中查找。只要 Python 在运行就一直有效。</li>
<li> 通过使用 <code>path.insert(0, new_path)</code>，你可以把一个新目录插入到 <code>sys.path</code> 的第一个位置，也就是 Python 搜索路径的开头。这就是你总想干的。在命名冲突的时候（比如，Python 倒入了一个特定库的第二版，但是你想用第三版的），这样做可以确保你指定的模块可以被找到和使用，而不是 Python 给的。</li>
</ol>
<h4 id="1-5-所有东西都是对象"><a href="#1-5-所有东西都是对象" class="headerlink" title="1.5. 所有东西都是对象"></a>1.5. 所有东西都是对象</h4><p>以防你没看到，我再说一遍，我之前说过 Python 函数都有属性，它们所有的属性在运行时都是可获取的。一个函数，像 Python 中的其他东西一样，都是一个对象。</p>
<p>打开交互式 Python Shell 然后跟着做：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> humansize                                                          ①</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(humansize.approximate_size(<span class="number">4096</span>, <span class="literal">True</span>))                             ②</span><br><span class="line"><span class="number">4.0</span> KiB</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(humansize.approximate_size.__doc__)                                 ③</span><br><span class="line">Convert a file size to human-readable form.</span><br><span class="line"></span><br><span class="line">    Keyword arguments:</span><br><span class="line">    size -- file size <span class="keyword">in</span> <span class="built_in">bytes</span></span><br><span class="line">    a_kilobyte_is_1024_bytes -- <span class="keyword">if</span> <span class="literal">True</span> (default), use multiples of <span class="number">1024</span></span><br><span class="line">                                <span class="keyword">if</span> <span class="literal">False</span>, use multiples of <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">    Returns: string</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li> 在第一行把 <code>humansize</code> 作为模块导入 - 如此一来我们就能交互式地使用一大坨代码或者一个更大的 Python 程序。一旦你导入了一个模块，你就能获得它里面任何一个公有函数，类或者属性的引用。模块也可以访问其他模块的功能，而且在交互式 Python Shell 中你也能做到。这是一个重要的概念，你以后会经常在这书里看到它。</li>
<li> 当你想使用定义在已导入模块内部的函数时，你需要带上模块名。所以你不能只写 <code>approximate_size</code>；它必须得是 <code>human size</code>.<code>approximate_size</code>。如果你用过 Java 中的类，这应该感觉有点相似。</li>
<li> 除了按照你想要的方式调用函数，你还可以调用这个函数的属性之一，__doc__。</li>
</ol>
<blockquote>
<p>Python 中的 <code>import</code> 就像 Perl 中的 <code>require</code>。一旦你导入了一个 Python 模块，你就可以用  <code>module.fuction</code> 这样的形式访问它的函数。一旦你导入了一个 Perl 模块，你就可以用 <code>module::function</code> 这样的形式访问它的函数。</p>
</blockquote>
<h5 id="1-5-1-对象是什么？"><a href="#1-5-1-对象是什么？" class="headerlink" title="1.5.1. 对象是什么？"></a>1.5.1. 对象是什么？</h5><p>Python 中的所有东西都是一个对象，而且所有东西都可以有属性和方法。所有的函数都有一个叫 <code>__doc__</code> 的属性，它可以返回定义在函数源代码里的文档字符串。sys 是个对象，它带有（除了其他东西之外）一个叫做 path 的属性。其它的也是类似。</p>
<p>这仍然回答不了最根本的问题：对象是什么？不同的编程语言用不同的方法定义了对象。有些指的是所有的对象必须有属性和方法，其它的指对象必须是可被继承的。在 Python 中的定义更宽松一点。一些对象既不用油属性也不用有方法，但是它们可以有。不是所有对象都是可被继承的。但是所有东西都是对象，也就是说它可以被分配给一个变量或者作为参数传给函数。</p>
<p>你可能在其他编程上下文中听说过一个术语，叫” 头等对象”。在 Python 中，函数是头等对象，你可以把一个函数当作参数传给其他函数。模块也是头等对象。你能把整个模块当作参数传给函数，类是头等对象，类的个别实例也是头等对象。</p>
<p>这一点很重要，以防你一会就忘了，所以我再强调一遍：在 Python 中的所有东西都是对象。字符串是对象，列表时对象，函数是对象，类是对象，类的实例也是对象，甚至模块也是对象。</p>
<h4 id="1-6-代码缩进"><a href="#1-6-代码缩进" class="headerlink" title="1.6. 代码缩进"></a>1.6. 代码缩进</h4><p>Python 函数没有明确的开始或者结束，而且没有大括号标志函数的代码在哪里开始或者停止。唯一的分隔符就是冒号（:）和代码自己的缩进。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">approximate_size</span>(<span class="params">size, a_kilobyte_is_1024_bytes=<span class="literal">True</span></span>):</span>                    ①</span><br><span class="line">    <span class="keyword">if</span> size &lt; <span class="number">0</span>:                                                              ②</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'number must be non-negative'</span>)                       ③</span><br><span class="line">                                                                              ④</span><br><span class="line">    multiple = <span class="number">1024</span> <span class="keyword">if</span> a_kilobyte_is_1024_bytes <span class="keyword">else</span> <span class="number">1000</span></span><br><span class="line">    <span class="keyword">for</span> suffix <span class="keyword">in</span> SUFFIXES[multiple]:                                         ⑤</span><br><span class="line">        size /= multiple</span><br><span class="line">        <span class="keyword">if</span> size &lt; multiple:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'{0:.1f} {1}'</span>.<span class="built_in">format</span>(size, suffix)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'number too large'</span>)</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li> 代码块通过他们的缩进被定义。关于代码块，我指的是函数，<code>if</code> 语句，<code>for</code> 循环， <code>while</code> 循环，等等。缩进是代码块的开始，不缩进是它的结束。没有明确的大括号，圆括号或者关键词。这意味着空格很重要，而且必须得一致。在这个例子中，函数块缩进了四个空格，它不需要必须是四个空格，只需要一致就好。第一行没有缩进的代码标记着函数的结束。</li>
<li> 在 Python 中，一个 <code>if</code> 语句后边跟着一个代码块。如果 <code>if</code> 表达式运算结果是 <code>True</code> ，就会执行 <code>if</code> 后面的缩进代码块，否则会跳到 <code>else</code> 代码块（如果有的话），注意表达式周围没有括号。</li>
<li> 这一行是在 <code>if</code> <code>代码块里边的。raise</code> 语句会抛出一个异常（ <code>ValueError</code> 异常 ），但是只在 <code>size &lt; 0</code> 成立的时候才抛出。</li>
<li> 这不是函数的结束。空行不被考虑在内。它们只是让代码更易读，但是它们不算是代码块的分隔符。函数会在下一行继续运行。</li>
<li> <code>for</code> 循环也标记着一个代码块的开始。代码块能容纳很多行，只要它们的缩进量都一样。这个 <code>for</code> 循环里面有三行代码。对于多行代码块也没有其他的特殊语法。只需要缩进就行了，继续享受生活吧。</li>
</ol>
<p>在一些最初的抱怨和一些对于类似 Fortran 的嘲讽之后，你会平和地对待它，开始看到它的好处。一个主要的好处就是由于缩进是一个语言要求而不是代码风格问题，所有的 Python 程序看起来都很相似。这让阅读和理解其他人的 Python 代码变得更容易了。</p>
<blockquote>
<p>Python 用回车符分隔语句，用冒号和缩进分隔代码块。C++ 和 Java 用分号分隔语句，用大括号分隔代码块。</p>
</blockquote>
<h4 id="1-7-异常"><a href="#1-7-异常" class="headerlink" title="1.7. 异常"></a>1.7. 异常</h4><p>在 Python 里边到处都有异常。实际上在 Python 标准库中的每个模块都用异常，而且在很多不同的情况下，Python 自身也会抛出异常。你会在书中反复地看到它们。</p>
<p>什么是异常？通常来说它是一个错误，一个表明有些东西错了的标志。（不是所有异常都是错误，但是现在先别担心那些。）一些编程语言鼓励使用可检查的错误返回代码。Python 鼓励使用可处理的异常。</p>
<p>当在 Python Shell 中发生一个错误的时候，它会打印输出一些关于这个异常和它是如何发生的详细信息，仅此而已。这叫做未处理的异常。当这个异常被抛出，没有代码会注意到这个异常然后处理它，因此它会输出它的调用路径和一些调试信息，然后就万事大吉了。在这个 shell 中，那不是什么大问题，但是如果它发生在你正在运行的实际的 Python 程序中，如果没有东西来处理这个异常的，整个程序就会嘎的一声停住。可能那就是你想要的，可能也不是。</p>
<blockquote>
<p>不像 Java ，Python 函数不声明它们会抛出什么异常。判断哪些异常需要捕获完全取决于你。</p>
</blockquote>
<p>尽管一个异常不一定会造成整个程序崩溃，但异常应该被处理。有时一个异常是因为你的代码里有 bug（像访问一个不存在的变量），但是有时一个异常是因为一些你能预料到的事。比如你要打开一个可能不存在的文件。比如你要导入一个可能没有安装的模块。比如你要链接一个可能不可达的或者没有访问权限的数据库。如果你知道哪行代码可能会抛出异常，你应该用 <code>try...except</code> 语句块处理异常。</p>
<blockquote>
<p>Python 用 <code>try...except</code> 语句块去处理异常，用 <code>raise</code> 语句来抛出异常。</p>
<p>Java 和 C++ 使用 <code>try...catch</code> 语句块去处理异常，用 throw 语句来抛出异常。</p>
</blockquote>
<p>这个 <code>approximate_size()</code> 函数在两种不同的情况下抛出异常：如果赋给 size 的值大于函数能处理的大小，或者小于零。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> size &lt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">raise</span> ValueError(<span class="string">'number must be non-negative'</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>这个抛出异常的语法太简单了。用跟着一个异常的名字和一个可有可无的给人看的字符串用来调试。这个语法让人联想到调用函数。（事实上，异常和类一样被执行，这个 <code>raise</code> 语句实际上创建了一个 <code>ValuerError</code> 类的实例并传递字符串 <code>'number must be non-negative'</code> 到它的初始化方法中。但是我们已经有些超前了！）</p>
<blockquote>
<p>你不需要在抛出异常的函数中处理这个异常。如果一个函数没处理它，这个异常会被传递到它的调用函数，然后函数的调用函数，调用函数的调用函数等等这些栈上面的。如果异常都没被处理，你的程序就会崩溃，Python 会打印一个 <code>"traceback"</code> 的标准错误信息，然后就完事了。再说一遍，可能这就是你想要的，这取决于你的程序做了什么。</p>
</blockquote>
<h4 id="1-7-1-捕获导入错误"><a href="#1-7-1-捕获导入错误" class="headerlink" title="1.7.1. 捕获导入错误"></a>1.7.1. 捕获导入错误</h4><p><code>ImportError</code> 是 Python 内建的异常之一，当你想导入一个模块但是失败了的时候就会抛出这个异常。这可能是由于多种原因引起的，但是最简单的原因就是在你的导入搜索路径中并不存在这个模块。你可以在你的程序中把这个作为你的已包含的可选特性来使用。例如，这个 <code>chardet</code> 库提供了字符编码的自动检测。或许你的程序想在这个库存在的情况下使用它，但是如果用户没安装它的话程序也得优雅地继续。你得用 <code>try...except</code> 语句块来导入。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> chardet</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    chardet = <span class="literal">None</span></span><br></pre></td></tr></tbody></table></figure>

<p>随后，你可以用简单的 <code>if</code> 语句检查 <code>chardet</code> 模块的存在状态。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> chardet:</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># continue anyway</span></span><br></pre></td></tr></tbody></table></figure>

<p>另一个 <code>ImportError</code> 的普遍用法是当两个模块可以实现相同的 API，但是一个比另一个更好。（可能它更快，或者占用内存少）你可以在尝试调用第一个模块失败的时候调用另一个。例如，在 XML 章节中讨论了两个实现同一个叫做 <code>ElementTree</code> 的 API 的模块。第一个叫做 <code>lxml</code>，这是个第三方模块，它需要你自己下载安装。第二个叫 <code>xml.etree.ElementTree</code>，它更慢一点但是是 Python 3 标准库的一部分。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> etree</span><br></pre></td></tr></tbody></table></figure>

<p>在 <code>try...except</code> 语句块的结尾，你导入了一些模块并把它命名为 etree。因为两个模块实现了相同的 API，在你其余的代码中不需要再一直检查导入了哪个模块了。因为这个一定会被导入的模块总是叫做 <code>etree</code>，其余的代码就不会因为用 <code>if</code> 语句调用不同名字的模块而被打乱。</p>
<h4 id="1-8-Unbound-变量"><a href="#1-8-Unbound-变量" class="headerlink" title="1.8. Unbound 变量"></a>1.8. Unbound 变量</h4><p>看一眼 <code>approximate_size()</code> 函数中的这行代码：</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">multiple = <span class="number">1024</span> <span class="keyword">if</span> a_kilobyte_is_1024_bytes <span class="keyword">else</span> <span class="number">1000</span></span><br></pre></td></tr></tbody></table></figure>

<p>你从来没声明过这个 <code>multiple</code> 变量，你就能直接给它赋值了。这样是可行的，因为 Python 允许你这样做。Python 不允许你做的是引用一个变量但是从来没给它赋值。这么做会抛出一个 <code>NameError</code> 异常。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'x'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>

<p>会有一天你要为这个感谢 Python。</p>
<h4 id="1-9-所有的东西都区分大小写"><a href="#1-9-所有的东西都区分大小写" class="headerlink" title="1.9. 所有的东西都区分大小写"></a>1.9. 所有的东西都区分大小写</h4><p>在 Python 中的所有名字都区分大小写：变量名，函数名，类名，模块名，异常名，如果你能获取它，设置它，调用它，构造它，导入它，或者抛出它，它就是区分大小写的。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>an_integer = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>an_integer</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>AN_INTEGER</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'AN_INTEGER'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>An_Integer</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'An_Integer'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>an_inteGer</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'an_inteGer'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></tbody></table></figure>

<p>诸如此类。</p>
<h4 id="1-10-运行脚本"><a href="#1-10-运行脚本" class="headerlink" title="1.10. 运行脚本"></a>1.10. 运行脚本</h4><p>Python 模块都是对象，而且还有几个有用的属性。你可以使用这个来轻松地测试你写的模块，通过包含仅在命令行运行时才会执行的一个特殊的代码块。来看看 <code>humansize.py</code> 的最后几行代码。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(approximate_size(<span class="number">1000000000000</span>, <span class="literal">False</span>))</span><br><span class="line">    print(approximate_size(<span class="number">1000000000000</span>))</span><br></pre></td></tr></tbody></table></figure>



<blockquote>
<p>和 C 一样的是，Python 用 <code>==</code> 来比较，用 <code>=</code> 来赋值。和 C 不一样的是，Python 不允许内嵌的赋值，所以不会出现你以为是在比较，实际上赋值了的情况。</p>
</blockquote>
<p>所以什么让这个 <code>if</code> 语句变得特殊了呢？好吧，模块都是对象，而且所有的模块都有一个叫做 <code>__name__</code> 的内置属性。一个模块的 <code>__name__</code> 取决于你怎么调用的这个模块。如果你导入了这个模块，那么这个 <code>__name__</code> 就是这个模块的名字，不带目录路径或者文件扩展名。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> humansize</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>humansize.__name__</span><br><span class="line"><span class="string">'humansize'</span></span><br></pre></td></tr></tbody></table></figure>

<p>但是你也可以把这个模块作为一个独立的程序来直接运行，这时候 <code>__name__</code> 会是一个特殊的默认值，<code>__main__</code>。Python 将会评判这个 <code>if</code> 语句，寻找一个为真的表达式，然后执行 <code>if</code> 代码块。在这个例子中，会打印两个值。</p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">c:\home\diveintopython3&gt; c:\python31\python.exe humansize.py</span><br><span class="line"><span class="number">1.0</span> TB</span><br><span class="line"><span class="number">931.3</span> GiB</span><br></pre></td></tr></tbody></table></figure>

<p>这就是你的第一个 Python 程序！</p>
<h3 id="1-11-深入阅读"><a href="#1-11-深入阅读" class="headerlink" title="1.11. 深入阅读"></a>1.11. 深入阅读</h3><p><a href="http://www.python.org/dev/peps/pep-0257/">PEP 257: Docstring Conventions</a> 解释了怎么来从一堆 docstring 中挑出好的 docstring。</p>
<p><a href="http://docs.python.org/3.1/tutorial/controlflow.html#documentation-strings">Python Tutorial: Documentation Strings</a> 也提到了这个主题。</p>
<p><a href="http://www.python.org/dev/peps/pep-0008/">PEP 8: Style Guide for Python Code</a> 讨论了好的缩进风格。</p>
<p><a href="http://docs.python.org/3.1/reference/">Python Reference Manual</a> 解释了 <a href="http://docs.python.org/3.1/reference/datamodel.html#objects-values-and-types">Python 中的所有东西都是对象</a> 意味着什么，因为有些人就是喜欢详细讨论一些东西的<a href="http://www.douglasadams.com/dna/pedants.html">书呆子</a>。</p>
]]></content>
      <tags>
        <tag>Python 之路</tag>
      </tags>
  </entry>
</search>
